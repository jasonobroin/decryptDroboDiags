// decodeData.go
//
// Copyright (c) 2016 Drobo Inc. All rights reserved
//
// Methods for decoding binary data files from Drobo diagnostics
//
// Various types of binary data files can be found in Drobo diagnostics, including binary data generated by
// the Drobo itself, binary data generated by Dashboard and associated services, and binary data generated by
// a third party source, such a crash dump
//
// All binary data files generated and uploaded from Drobo and the Dashboard apps will be wrapped in a
// common header, indicating appropriate metadata such as time/data the data was collected, endianness,
// data format identifier, platform, operating system (if appropriate), length etc.
//
// Design ideas
// ============
//
// Generic interface to decode a binary file - pass reader/writers in/out.
// We have a header we need to decode, and then work out how to decode
// Have a registration function so that decoders can register with the package
// Move to package (or packages?)
// Use cgo to access header structures?
//
// Non Drobo generated binary files will be handled elsewhere
package binary

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"log"
	"os"
	"time"

	// Might want to move this up to main for scalability
	//	_ "decryptDiags/binary/eventlog"
)

// Should this be a type?
const (
	BinaryFile_FlashEventLog = iota
	BinaryFile_DiskEventLog
	BinaryFile_CachedEventLog
	BinaryFile_ZoneTable
	BinaryFile_PerfLog
)

//var BinaryType = map[uint32]string{
//	iota: "flasheventlog",
//	iota: "diskeventlog",
//	iota: "cacheeventlog",
//	iota: "zonetable",
//}

const (
	BinaryFile_ArchARM = iota
	BinaryFile_ArchMIPS
)

// VxWorks version defined in HostAppManager.h
const (
	BinaryFile_PlatformDrobo = iota
	BinaryFile_PlatformDrobie
	BinaryFile_PlatformDroboPro
	BinaryFile_PlatformDrobo3
	BinaryFile_PlatformDroboNAS
	BinaryFile_PlatformGort
	BinaryFile_PlatformVoltron
	BinaryFile_PlatformB800i
	BinaryFile_PlatformB800fs
	BinaryFile_Platform5D
	BinaryFile_Platform5N
	BinaryFile_PlatformB810n
	BinaryFile_PlatformB810i
	BinaryFile_PlatformBender
	BinaryFile_PlatformGerty
)

const (
	BinaryFile_OSVxWorks = iota
	BinaryFile_OSLinux
	BinaryFile_OSMac
	BinaryFile_OSWindows
)

const (
	BinaryFile_FirmwareVersion_Len = 32
	BinaryFile_OSVersion_Len       = 32
)

// Header information to encode the type of binary file. Encode this as JSON?
type BinaryHdr struct {
	HeaderVersion uint32

	DiagBinaryType          uint32 // What data is this? Use a string?
	DiagBinaryFormatVersion uint32 // Which version?

	Platform          uint32 // 5D, 5N, etc
	Architecture      uint32 // ARM, MIPS
	Endianness        uint32 // LittleEndian, BigEndian
	FirmwareVersion   [BinaryFile_FirmwareVersion_Len]byte
	OS                uint32 // VxWorks, Linux, Mac, Windows, etc.
	OSVersion         [BinaryFile_OSVersion_Len]byte
	CreationTimestamp uint32
	Reserved1         uint32
	Reserved2         uint32

	ImageSize uint32
	// Data follows immediately after header
}

// Header information to encode the type of binary file. Encode this as JSON?
type droboDiagBinaryHdr struct {
	HeaderVersion uint32 `json:"headerVersion"`

	DiagBinaryType          string `json:"diagBinaryType"`          // What data is this?
	DiagBinaryFormatVersion uint32 `json:"diagBinaryFormatVersion"` // Which version?

	Platform          string `json:"platform"`   // 5D, 5N, etc
	Architecture      string `json:"arch"`       // ARM, MIPS
	Endianness        bool   `json:"endianness"` // 0 = little; 1 = big
	FirmwareVersion   string `json:"firmwareVersion"`
	OS                string `json:"OS"` // VxWorks, Linux, Mac, Windows, etc.
	OSVersion         string `json:"OSVersion"`
	CreationTimestamp uint32 `json:"creationTimestamp"`

	ImageSize uint32 `json:"imageSize"` // Is this needed
	// Data follows immediately after header
	// Payload ... an array of base64 encoding? A binary array? What's best to encode in JSON?
}

func DecodeDataFile(filename string, decodeFilename string) {
	reader, err := os.Open(filename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer reader.Close()

	writer, err := os.Create(decodeFilename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer writer.Close()
	fmt.Println("Decoded to", decodeFilename)

	DecodeFile(reader, writer)
}

// Move this to its own file, and make an interface?
func DecodeFile(reader io.Reader, writer io.Writer) {

	var binHdr BinaryHdr

	// Read in header, and pass rest of file through to decoder to process
	// Main header is in network byte order
	err := binary.Read(reader, binary.BigEndian, &binHdr)
	if err != nil {
		fmt.Println(err)
		return
	}

	// Report binary file header

	fmt.Fprintln(writer, "------------------- BINARY DECODE -------------------")
	t := time.Unix(int64(binHdr.CreationTimestamp), 0)
	fmt.Fprintf(writer, "Decode of binary file format %d (version %d) created at %s\n", binHdr.DiagBinaryType, binHdr.DiagBinaryFormatVersion, t.UTC().Format(time.UnixDate))

	l := bytes.IndexByte(binHdr.FirmwareVersion[:], 0) // find the EOL
	if l < 0 {
		l = BinaryFile_FirmwareVersion_Len
	}
	if l > 0 {
		io.WriteString(writer, "Firmware version: "+string(binHdr.FirmwareVersion[:l]))
	}

	fmt.Fprintf(writer, " Platform %d Architecture %d Endianness %d OS %d\n\n", binHdr.Platform, binHdr.Architecture, binHdr.Endianness, binHdr.OS)

	// The callHandler should work out which which function to call from the binaryHdr
	_ = callHandler(binHdr, writer, reader)
}

type Decoder interface {
	Decoder(b BinaryHdr, w io.Writer, r io.Reader) error
}

//Handler registration - basically a map; is there a package to auto handle this?

// need to change this to have a calling signature - probably a writer, and the JSON containing the header; maybe a reader if we're not
// read the payload into memory yet
var handlers = map[uint32]Decoder{}

func RegisterDecoder(id uint32, d Decoder) {
	handlers[id] = d
	log.Println("Register diag decoder handler for", id)
}

func callHandler(b BinaryHdr, w io.Writer, r io.Reader) error {
	if decoder, ok := handlers[b.DiagBinaryType]; ok {
		log.Println("Calling diag decoder handler for", b.DiagBinaryType)
		return decoder.Decoder(b, w, r)
	} else {
		log.Println("Failed to find diag decoder for", b.DiagBinaryType)
	}
	return nil // should this return some indication that the handler wasn't found?
}
